#include <stdio.h>

int main() {
    int arr[3] = {10, 20, 30};
    int *sp = arr;

    printf("Before increment: sp = %p, *sp = %d\n", (void*)sp, *sp);

    int result = *sp++;  // 解引用当前 sp 的值，然后 sp 自增

    printf("result: %d\n", result);
    printf("After increment: sp = %p, *sp = %d\n", (void*)sp, *sp);

    return 0;
}




// 输出
/*
Before increment: sp = 0x16b9d2f98, *sp = 10
result: 10
After increment: sp = 0x16b9d2f9c, *sp = 20
*/












/*
int r = *sp++; 具体步骤如下：

先执行 sp++： 由于 sp++ 是后缀自增操作，这个操作会先返回指针 sp 当前的值，然后 sp 的值增加 1。
然后进行解引用 *sp： 使用 sp 自增前的值进行解引用操作，得到指针原本指向地址中的值。
将解引用的值赋给 r： 将 *sp 的值赋给变量 r。

解引用时，为什么是自增前的值，而不是自增后的值？

这是因为后缀自增运算符 (sp++) 的工作方式。后缀自增运算符在使用变量当前值之前就会执行自增操作，但在返回之前保持原值。这意味着在 *sp++ 这种表达式中，自增操作会在解引用之前发生，但解引用仍然会使用自增前的值。

为了更详细地解释这一点，我们需要深入了解后缀自增运算符的行为。

后缀自增运算符 (sp++)
后缀自增运算符首先会计算并返回变量的当前值，然后将变量的值增加 1。这个操作可以分解成以下步骤：

保存当前值： 保留变量当前的值，以便稍后返回。
执行自增： 将变量的值增加 1。
返回旧值： 返回保存的旧值。
因此，在 *sp++ 表达式中：

保存当前指针值 sp（比如它指向地址 0x1000）。
执行自增操作，更新 sp 的值（使 sp 指向地址 0x1004，假设 int 类型占 4 字节）。
返回保存的旧值（0x1000），用于解引用操作。
操作顺序示例
假设指针 sp 当前指向地址 0x1000，且 0x1000 处的值为 42。

sp++ 操作：

sp 目前指向 0x1000。
sp++ 返回当前指针 sp 的值 0x1000，然后将 sp 增加 1（sp 变为 0x1004）。
解引用 *sp：

使用保存的旧值 0x1000 进行解引用，得到 0x1000 处的值 42。
赋值 r：

将解引用操作获取到的值 42 赋给 r。
*/


























